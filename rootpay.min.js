!function(e,n){"object"==typeof exports&&"object"==typeof module?module.exports=n():"function"==typeof define&&define.amd?define([],n):"object"==typeof exports?exports.RootPay=n():e.RootPay=n()}(this,(()=>(()=>{var __webpack_modules__={"./root-pay.js":module=>{eval("(function (window) {\n  'use strict';\n\n  // Main namespace for the RootPay library\n  const RootPay = {};\n\n  // Configuration and state\n  let config = {\n    token: null,\n    apiBaseUrl: null,\n    debug: false,\n    fields: {},\n    formState: {\n      isValid: false,\n      isDirty: false,\n      isFocused: false,\n      isEmpty: true,\n      fields: {}\n    },\n    payee_id: null,\n    callbacks: {}\n  };\n\n  // Store active requests to match responses\n  const activeRequests = {};\n\n  /**\n   * Debug logger function - only logs if debug mode is enabled\n   * @param {...any} args - Arguments to log\n   */\n  function log() {\n    if (config.debug) {\n      console.log(...arguments);\n    }\n  }\n\n  /**\n   * Debug error logger function - only logs if debug mode is enabled\n   * @param {...any} args - Arguments to log\n   */\n  function logError() {\n    if (config.debug) {\n      console.error(...arguments);\n    }\n  }\n\n  /**\n   * Debug warning logger function - only logs if debug mode is enabled\n   * @param {...any} args - Arguments to log\n   */\n  function logWarn() {\n    if (config.debug) {\n      console.warn(...arguments);\n    }\n  }\n\n  /**\n   * Update field configuration\n   * @param {string} fieldId - Field ID\n   * @param {Object} options - New field options\n   * @returns {boolean} Success status\n   */\n  function updateField(fieldId, options) {\n    const field = config.fields[fieldId];\n    if (!field || !field.iframe) {\n      return false;\n    }\n\n    // Update field configuration\n    if (options.style) {\n      field.config.style = {\n        ...field.config.style,\n        ...options.style\n      };\n    }\n    if (options.placeholder !== undefined) {\n      field.config.placeholder = options.placeholder;\n    }\n\n    // Send configuration update to iframe\n    field.iframe.contentWindow.postMessage({\n      action: 'UPDATE_FIELD',\n      fieldId: fieldId,\n      config: {\n        style: field.config.style,\n        placeholder: field.config.placeholder\n      }\n    }, '*'); // Allow communication with any origin\n\n    return true;\n  }\n\n  /**\n   * Initialize the RootPay library with configuration\n   * @param {Object} options - Configuration options\n   * @param {string} options.token - API token for authentication\n   * @param {string} options.payee_id - Payee ID for the customer\n   * @param {string} [options.apiBaseUrl] - Base URL for API requests\n   * @param {boolean} [options.debug] - Enable debug logging\n   * @param {Function} [options.onSuccess] - Callback when payment method is added successfully\n   * @param {Function} [options.onError] - Callback when an error occurs, receives error message and details object\n   * @returns {Object} RootPay instance\n   */\n  RootPay.init = function (options) {\n    if (!options || !options.token) {\n      throw new Error('RootPay: token is required');\n    }\n    if (!options || !options.payee_id) {\n      throw new Error('RootPay: payee_id is required');\n    }\n\n    // Set configuration\n    config.token = options.token;\n    config.payee_id = options.payee_id;\n    config.debug = !!options.debug;\n\n    // Set API base URL with default\n    config.apiBaseUrl = options.apiBaseUrl || 'http://localhost:8000';\n    log(`[RootPay] Initializing with API base URL: ${config.apiBaseUrl}`);\n\n    // Set up global message handler for iframe communications\n    setupGlobalMessageHandler();\n    config.callbacks.onSuccess = options.onSuccess || function () {};\n    config.callbacks.onError = options.onError || function () {};\n\n    // Create instance\n    const instance = createInstance();\n\n    // Return the public API\n    return instance;\n  };\n\n  /**\n   * Set up global message listener for iframe communications\n   */\n  function setupGlobalMessageHandler() {\n    // Listen for messages from all iframes\n    window.addEventListener('message', function (event) {\n      log(`[RootPay] Received global message:`, event.data);\n\n      // We accept messages from any origin since iframes can be embedded anywhere\n      // But we verify the message format and content\n\n      const message = event.data;\n      if (!message || typeof message !== 'object') {\n        return; // Ignore non-object messages\n      }\n\n      // Handle API response messages\n      if (message.requestId) {\n        log(`[RootPay] Processing message with requestId: ${message.requestId}`);\n        if (activeRequests[message.requestId]) {\n          const request = activeRequests[message.requestId];\n          log(`[RootPay] Found matching request for ${message.requestId}, clearing timeout`);\n\n          // Clear timeout and delete request\n          clearTimeout(request.timeoutId);\n          delete activeRequests[message.requestId];\n\n          // Call the appropriate callback\n          if (message.success) {\n            log(`[RootPay] Request ${message.requestId} succeeded, calling success callback`);\n            request.callback(201, message.data);\n            config.callbacks.onSuccess(message.data);\n          } else {\n            // Capture more detailed error information\n            let errorMessage = message.error || 'Unknown error';\n            log(`[RootPay] Request ${message.requestId} failed: ${errorMessage}`);\n\n            // Include the status code and error details if available\n            const statusCode = message.status || 400;\n            const errorResponse = {\n              error: errorMessage,\n              details: message.errorDetails || null,\n              status: statusCode\n            };\n            logError('[RootPay] Error details:', errorResponse);\n            request.callback(statusCode, errorResponse);\n            config.callbacks.onError(errorMessage, errorResponse);\n          }\n          return;\n        } else {\n          logWarn(`[RootPay] Received response for unknown request: ${message.requestId}`);\n        }\n      }\n\n      // Handle field state change messages\n      if (message.type === 'FIELD_STATE_CHANGE' && message.fieldId) {\n        const fieldId = message.fieldId;\n        if (config.fields[fieldId]) {\n          log(`[RootPay] Updating field state for ${fieldId} with value:`, message.state.value);\n\n          // Get the field\n          const field = config.fields[fieldId];\n\n          // Update field state directly\n          Object.assign(field.state, message.state);\n\n          // Make sure value is present in the field state\n          if (message.state.value !== undefined) {\n            field.state.value = message.state.value;\n            log(`[RootPay] Set field ${fieldId} value to:`, message.state.value);\n          }\n\n          // Ensure the field type is used for form state lookup\n          const fieldName = message.fieldType || field.config.name;\n\n          // Update form state using the field type as the key\n          config.formState.fields[fieldName] = field.state;\n\n          // Debugging: Check mappings\n          log(`[RootPay] Field mapping: ID=${fieldId}, Type=${message.fieldType}, Name=${field.config.name}`);\n          log(`[RootPay] Added to form state with key: ${fieldName}`);\n\n          // Calculate overall form validity\n          let isValid = true;\n          let isEmpty = true;\n          Object.keys(config.formState.fields).forEach(fieldName => {\n            const field = config.formState.fields[fieldName];\n            if (!field.isValid) {\n              isValid = false;\n            }\n            if (!field.isEmpty) {\n              isEmpty = false;\n            }\n          });\n          config.formState.isValid = isValid;\n          config.formState.isEmpty = isEmpty;\n\n          // Log current form state after field update\n          log(`[RootPay] Current form state after update:`, config.formState.fields);\n        }\n        return;\n      }\n\n      // Handle iframe ready messages\n      if (message.type === 'IFRAME_READY' && message.fieldId) {\n        const fieldId = message.fieldId;\n        if (config.fields[fieldId]) {\n          log(`[RootPay] Field ${fieldId} iframe is ready`);\n          config.fields[fieldId].isReady = true;\n\n          // Apply any pending styles\n          const fieldConfig = config.fields[fieldId].config;\n          if (fieldConfig.style && Object.keys(fieldConfig.style).length > 0) {\n            updateField(fieldId, {\n              style: fieldConfig.style\n            });\n          }\n\n          // Apply placeholder if provided\n          if (fieldConfig.placeholder) {\n            updateField(fieldId, {\n              placeholder: fieldConfig.placeholder\n            });\n          }\n        }\n        return;\n      }\n    });\n    log('[RootPay] Global message handler set up');\n  }\n\n  /**\n   * Create a new RootPay instance\n   * @returns {Object} Instance with public methods\n   */\n  function createInstance() {\n    /**\n     * Make an authenticated API request to RootPay via iframe\n     * @param {string} endpoint - API endpoint path\n     * @param {Object} data - Request data\n     * @param {Function} callback - Callback function\n     */\n    function sendIframeRequest(endpoint, data, callback) {\n      // Create a unique request ID\n      const requestId = `request-${generateId()}`;\n      log(`[RootPay] Sending request ${requestId} to endpoint: ${endpoint}`, data);\n\n      // Get available iframes\n      const iframes = Object.values(config.fields).map(field => field.iframe).filter(Boolean);\n      if (iframes.length === 0) {\n        logError('[RootPay] No secure fields found');\n        callback(400, {\n          error: 'No secure fields found'\n        });\n        return;\n      }\n      log(`[RootPay] Found ${iframes.length} iframes, using the first one`);\n\n      // Prepare the message to send\n      const message = {\n        action: 'API_REQUEST',\n        endpoint: endpoint,\n        data: data,\n        token: config.token,\n        requestId: requestId,\n        payee_id: config.payee_id,\n        timestamp: new Date().getTime()\n      };\n\n      // Store active request first, before sending\n      // This prevents race conditions where the response comes before we set up the request\n      const timeoutId = setTimeout(() => {\n        logWarn(`[RootPay] Request ${requestId} timed out after 15 seconds`);\n        if (activeRequests[requestId]) {\n          delete activeRequests[requestId];\n          callback(408, {\n            error: 'Request timed out - server may be down or unreachable'\n          });\n        }\n      }, 15000);\n\n      // Register request before sending\n      activeRequests[requestId] = {\n        callback: callback,\n        timeoutId: timeoutId,\n        sentAt: new Date()\n      };\n      log(`[RootPay] Registered request ${requestId} in activeRequests`, Object.keys(activeRequests));\n      try {\n        // Check if the iframe is ready\n        if (!iframes[0].contentWindow) {\n          throw new Error('Iframe contentWindow is not available');\n        }\n        log(`[RootPay] Sending message to iframe:`, message);\n\n        // Send the request through the first available iframe\n        // Use '*' to allow communication with any origin\n        iframes[0].contentWindow.postMessage(message, '*');\n        log(`[RootPay] Request ${requestId} sent to iframe`);\n      } catch (error) {\n        logError('[RootPay] Error sending request to iframe:', error);\n\n        // Clean up the registered request on error\n        clearTimeout(timeoutId);\n        delete activeRequests[requestId];\n        callback(500, {\n          error: 'Failed to send request to iframe: ' + error.message\n        });\n      }\n    }\n\n    /**\n     * Create and setup a field iframe for collecting payment information\n     * @param {string} selector - CSS selector for the container element\n     * @param {Object} options - Field configuration options\n     * @returns {Object} Field controller\n     */\n    function createField(selector, options) {\n      // Get container element\n      const container = document.querySelector(selector);\n      if (!container) {\n        throw new Error(`RootPay: Container element not found for selector: ${selector}`);\n      }\n\n      // Create field ID\n      const fieldId = `secure-field-${generateId()}`;\n      log(`[RootPay] Creating field with ID: ${fieldId}`, options);\n\n      // Setup field configuration with defaults\n      const fieldConfig = Object.assign({\n        type: 'text',\n        name: fieldId,\n        placeholder: '',\n        style: {} // Default empty style object\n      }, options);\n\n      // Ensure name is properly set - use type for field key if available\n      if (options.type) {\n        fieldConfig.name = options.type;\n        log(`[RootPay] Using type as field name: ${options.type}`);\n      } else if (!options.name) {\n        logWarn(`[RootPay] Field name not provided, using ID as name: ${fieldId}`);\n      }\n\n      // Create field state\n      const fieldState = {\n        id: fieldId,\n        name: fieldConfig.name,\n        type: fieldConfig.type,\n        isValid: false,\n        isEmpty: true,\n        isFocused: false,\n        errors: [],\n        value: '' // Initialize with empty value\n      };\n      log(`[RootPay] Field state initialized:`, fieldState);\n\n      // Store field in configuration\n      config.fields[fieldId] = {\n        config: fieldConfig,\n        element: container,\n        iframe: null,\n        state: fieldState,\n        isReady: false\n      };\n\n      // Update form state with the new field - use name as key\n      // Important: Use type as the key for form state if it's a known field type\n      const formFieldKey = fieldConfig.type || fieldConfig.name;\n      config.formState.fields[formFieldKey] = fieldState;\n      log(`[RootPay] Added field to form state with key: ${formFieldKey}`);\n      updateFormState({});\n\n      // Create iframe for the field\n      createFieldIframe(container, fieldId, fieldConfig);\n      return {\n        id: fieldId,\n        update: function (newOptions) {\n          return updateField(fieldId, newOptions);\n        }\n      };\n    }\n\n    /**\n     * Generate a unique ID\n     * @returns {string} Unique ID\n     */\n    function generateId() {\n      return Math.random().toString(36).substring(2, 15);\n    }\n\n    /**\n     * Create an iframe for a secure field\n     * @param {HTMLElement} container - Container element\n     * @param {string} fieldId - Field ID\n     * @param {Object} fieldConfig - Field configuration\n     */\n    function createFieldIframe(container, fieldId, fieldConfig) {\n      // Create iframe element\n      const iframe = document.createElement('iframe');\n      iframe.id = fieldId;\n      iframe.name = fieldId;\n      iframe.setAttribute('frameborder', '0');\n      iframe.setAttribute('scrolling', 'no');\n      iframe.setAttribute('allowtransparency', 'true');\n\n      // Set iframe styling to fill the container completely\n      iframe.style.width = '100%';\n      iframe.style.height = '100%';\n      iframe.style.border = 'none';\n      iframe.style.outline = 'none';\n      iframe.style.overflow = 'hidden';\n      iframe.style.backgroundColor = 'transparent';\n\n      // Set source to unified secure-field endpoint with the exact parameter names from the FastAPI endpoint\n      let iframeSrc = `${config.apiBaseUrl}/collect/secure-field?field_id=${encodeURIComponent(fieldId)}&field_type=${encodeURIComponent(fieldConfig.type)}`;\n\n      // Add placeholder if provided\n      if (fieldConfig.placeholder) {\n        iframeSrc += `&placeholder=${encodeURIComponent(fieldConfig.placeholder)}`;\n      }\n\n      // Hide label by default\n      iframeSrc += `&show_label=false`;\n\n      // Add styling parameters to match the existing UI - remove borders since the container already has them\n      iframeSrc += `&input_border=none`;\n      iframeSrc += `&input_border_radius=0px`;\n      iframeSrc += `&input_padding=0 12px`; // Horizontal padding only\n      iframeSrc += `&font_size=16px`;\n      iframeSrc += `&input_background=transparent`;\n      iframeSrc += `&input_color=#333`;\n      iframeSrc += `&font_family=Arial, sans-serif`; // Match the page font\n\n      log(`[RootPay] Creating iframe with source:`, iframeSrc);\n      iframe.setAttribute('src', iframeSrc);\n\n      // Store iframe reference\n      config.fields[fieldId].iframe = iframe;\n\n      // Append iframe to container\n      container.appendChild(iframe);\n\n      // Log when iframe loads\n      iframe.onload = function () {\n        log(`[RootPay] Iframe ${fieldId} has loaded`);\n      };\n    }\n\n    /**\n     * Update form state\n     * @param {Object} newState - New state to merge with current state\n     */\n    function updateFormState(newState) {\n      // Update the state\n      config.formState = Object.assign({}, config.formState, newState);\n\n      // Calculate overall form validity\n      let isValid = true;\n      let isEmpty = true;\n      Object.keys(config.formState.fields).forEach(fieldName => {\n        const field = config.formState.fields[fieldName];\n        if (!field.isValid) {\n          isValid = false;\n        }\n        if (!field.isEmpty) {\n          isEmpty = false;\n        }\n      });\n      config.formState.isValid = isValid;\n      config.formState.isEmpty = isEmpty;\n      return config.formState;\n    }\n\n    /**\n     * Submit the payment method form to create a new payment method\n     * @param {Function} callback - Callback function\n     * @param {string} type - Type of payment method ('card' or 'bank')\n     */\n    function submitPaymentMethod(callback) {\n      let type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'card';\n      // Debug log to see form state\n      log('Form state before submission:', config.formState);\n\n      // Check if we have any fields configured\n      if (Object.keys(config.fields).length === 0) {\n        logError('[RootPay] No fields configured before submission');\n        callback(400, {\n          error: 'No fields configured'\n        });\n        return;\n      }\n\n      // Force a refresh of all field values from iframes before submission\n      log('[RootPay] Requesting field values from iframes...');\n      const iframes = Object.values(config.fields).map(field => field.iframe).filter(Boolean);\n      let pendingRefreshes = iframes.length;\n\n      // If no iframes, proceed directly\n      if (pendingRefreshes === 0) {\n        _processSubmission(callback, type);\n        return;\n      }\n\n      // Create a one-time listener for field value updates\n      const fieldUpdateListener = function (event) {\n        const message = event.data;\n        if (message && message.type === 'FIELD_STATE_CHANGE') {\n          pendingRefreshes--;\n          log(`[RootPay] Received field update, ${pendingRefreshes} pending`);\n          if (pendingRefreshes <= 0) {\n            // All fields have reported back\n            window.removeEventListener('message', fieldUpdateListener);\n            _processSubmission(callback, type);\n          }\n        }\n      };\n\n      // Set up listener for field updates\n      window.addEventListener('message', fieldUpdateListener);\n\n      // Request updates from all iframes\n      iframes.forEach(iframe => {\n        try {\n          iframe.contentWindow.postMessage({\n            action: 'GET_FIELD_VALUE',\n            fieldId: iframe.id\n          }, '*');\n        } catch (e) {\n          logError('[RootPay] Error requesting field value:', e);\n          pendingRefreshes--;\n        }\n      });\n\n      // Set a timeout to proceed anyway if not all fields respond\n      setTimeout(() => {\n        if (pendingRefreshes > 0) {\n          logWarn(`[RootPay] Timeout waiting for ${pendingRefreshes} field updates, proceeding anyway`);\n          window.removeEventListener('message', fieldUpdateListener);\n          _processSubmission(callback, type);\n        }\n      }, 1000);\n    }\n    function _processSubmission(callback) {\n      let type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'card';\n      // Check if the fields have values\n      let missingValues = false;\n      let noValueFields = [];\n\n      // Get field values from form state\n      const fields = config.formState.fields;\n\n      // Debug all fields to see what we have\n      log('[RootPay] All fields before submission:', config.fields);\n      log('[RootPay] Form state fields before submission:', fields);\n\n      // Check if fields have the expected structure with values\n      Object.keys(fields).forEach(fieldName => {\n        const field = fields[fieldName];\n        if (!field.value) {\n          missingValues = true;\n          noValueFields.push(fieldName);\n        }\n      });\n      if (missingValues) {\n        logError('[RootPay] Some fields are missing values:', noValueFields);\n\n        // Try to get values directly from field states\n        let allFieldsResolved = true;\n        if (type === 'card') {\n          let cardNumberValue = fields['card-number']?.value;\n          let cardExpiryValue = fields['card-expiry']?.value;\n\n          // Look in all field states if values are missing\n          if (!cardNumberValue || !cardExpiryValue) {\n            Object.keys(config.fields).forEach(fieldId => {\n              const field = config.fields[fieldId];\n              if (field.config.type === 'card-number' && !cardNumberValue) {\n                cardNumberValue = field.state.value;\n                // Update form state\n                if (cardNumberValue) {\n                  config.formState.fields['card-number'].value = cardNumberValue;\n                  log(`[RootPay] Updated card number value from field state: ${cardNumberValue}`);\n                }\n              } else if (field.config.type === 'card-expiry' && !cardExpiryValue) {\n                cardExpiryValue = field.state.value;\n                // Update form state\n                if (cardExpiryValue) {\n                  config.formState.fields['card-expiry'].value = cardExpiryValue;\n                  log(`[RootPay] Updated card expiry value from field state: ${cardExpiryValue}`);\n                }\n              }\n            });\n            if (!cardNumberValue || !cardExpiryValue) {\n              allFieldsResolved = false;\n            }\n          }\n        } else if (type === 'bank') {\n          // Similar process for bank fields\n          let accountNumberValue = fields['account-number']?.value;\n          let routingNumberValue = fields['routing-number']?.value;\n\n          // Look in all field states if values are missing\n          if (!accountNumberValue || !routingNumberValue) {\n            Object.keys(config.fields).forEach(fieldId => {\n              const field = config.fields[fieldId];\n              if (field.config.type === 'account-number' && !accountNumberValue) {\n                accountNumberValue = field.state.value;\n                // Update form state\n                if (accountNumberValue) {\n                  config.formState.fields['account-number'].value = accountNumberValue;\n                  log(`[RootPay] Updated account number value from field state: ${accountNumberValue}`);\n                }\n              } else if (field.config.type === 'routing-number' && !routingNumberValue) {\n                routingNumberValue = field.state.value;\n                // Update form state\n                if (routingNumberValue) {\n                  config.formState.fields['routing-number'].value = routingNumberValue;\n                  log(`[RootPay] Updated routing number value from field state: ${routingNumberValue}`);\n                }\n              }\n            });\n            if (!accountNumberValue || !routingNumberValue) {\n              allFieldsResolved = false;\n            }\n          }\n        }\n        if (!allFieldsResolved) {\n          callback(400, {\n            error: 'Some fields are missing values: ' + noValueFields.join(', ')\n          });\n          return;\n        }\n      }\n      let requestData = {};\n      let endpoint = '';\n      if (type === 'card') {\n        // Normal card submission\n        log('[RootPay] Preparing card submission with fields:', fields);\n        const cardNumber = fields['card-number']?.value;\n        let cardExpiry = fields['card-expiry']?.value;\n        if (!cardNumber || !cardExpiry) {\n          logError('[RootPay] Missing required card fields:', {\n            cardNumber: !!cardNumber,\n            cardExpiry: !!cardExpiry\n          });\n          callback(400, {\n            error: 'Card number and expiry are required'\n          });\n          return;\n        }\n\n        // Transform expiry from \"MM/YY\" to \"MMYY\" format\n        cardExpiry = cardExpiry.replace('/', '');\n        requestData = {\n          card_number: cardNumber,\n          card_expiry_date: cardExpiry\n        };\n        endpoint = `/api/payees/${config.payee_id}/payment-methods/push-to-card`;\n      } else if (type === 'bank') {\n        // Bank account submission\n        log('[RootPay] Preparing bank submission with fields:', fields);\n        const accountNumber = fields['account-number']?.value;\n        const routingNumber = fields['routing-number']?.value;\n        if (!accountNumber || !routingNumber) {\n          logError('[RootPay] Missing required bank fields:', {\n            accountNumber: !!accountNumber,\n            routingNumber: !!routingNumber\n          });\n          callback(400, {\n            error: 'Account number and routing number are required'\n          });\n          return;\n        }\n        requestData = {\n          account_number: accountNumber,\n          routing_number: routingNumber,\n          routing_number_type: 'aba'\n        };\n        endpoint = `/api/payees/${config.payee_id}/payment-methods/pay-to-bank`;\n      } else {\n        logError('[RootPay] Invalid payment method type:', type);\n        callback(400, {\n          error: 'Invalid payment method type'\n        });\n        return;\n      }\n\n      // Send the request through the iframe\n      sendIframeRequest(endpoint, requestData, callback);\n    }\n\n    /**\n     * Get the current form state\n     * @returns {Object} Current form state\n     */\n    function getFormState() {\n      return JSON.parse(JSON.stringify(config.formState));\n    }\n\n    // Return the public API - limited to only adding payment methods\n    return {\n      field: createField,\n      submitPaymentMethod: submitPaymentMethod,\n      getFormState: getFormState\n    };\n  }\n\n  // Expose the RootPay object globally\n  window.RootPay = RootPay;\n\n  // Export for webpack\n  if ( true && module.exports) {\n    module.exports = RootPay;\n  }\n})(window);\n\n//# sourceURL=webpack://RootPay/./root-pay.js?")}},__webpack_module_cache__={};function __webpack_require__(e){var n=__webpack_module_cache__[e];if(void 0!==n)return n.exports;var t=__webpack_module_cache__[e]={exports:{}};return __webpack_modules__[e](t,t.exports,__webpack_require__),t.exports}var __webpack_exports__=__webpack_require__("./root-pay.js");return __webpack_exports__})()));